<!doctype html><html class="not-ready lg:text-base" style=--bg:#fff lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Go Learn - Wei's Note</title>
<meta name=theme-color><meta name=description content='数据类型
array

初始化， b := [2]string{"Penn", "Teller"}
初始化，编译器计算自动计算长度 b := [...]string{"Penn", "Teller"}
数组的赋值是直接拷贝整个数组，变量赋值本质上是一次内存浅拷贝，切片的赋值是拷贝了切片头，字符串的赋值是拷贝了字符串的头部，接口变量的赋值同样是浅拷贝

string
Strings, bytes, runes and characters in Go
等价于一个只读的字节Slice
len 方法返回的时候字节数，非字符数
rune
int32 4个字节  单括号字面量
关键字
switch

不需要break语句
支持表达式

容器
Slice - 切片
Go Slices: usage and internals

初始化， letters := []string{"a", "b", "c", "d"}
make初始化， s := make([]byte, 5(leg), 5(cap,可选，不填写默认与长度相同))


与Java不同，扩容后返回新Slicce，一定要接收返回值
nil slice 支持append
s[x:y] 共享底层数据，小Slice引用大Slice，可能会早成无法被垃圾回收，使用复制去处对大Slice的引用

Map

初始化 n := map[string]int{"foo": 1, "bar": 2}
make初始化 m := make(map[string]int)
v1 := m["k1"]
v2, ok := m["k2"] ok 判断是否存在，主要用于区分零值

range -迭代器

数组 or 切片 for i, num := range nums
字典 for k, v := range kvs  for k := range kvs
字符串 for offset, runeValue := range "go"

Struct
参数传递
Go 语言支持值传递，也支持指针传递。值传递涉及到结构体字段的浅拷贝，指针传递会共享结构体内容，只会拷贝指针地址'><meta name=author content="Wei"><link rel="preload stylesheet" as=style href=https://blog.ww93.fun/main.min.css><link rel=preload as=image href=https://blog.ww93.fun/theme.png><link rel=preload as=image href="https://www.gravatar.com/avatar/f6245ed95683bb2f5b20fcd77fcb6e2b?s=160&amp;d=identicon"><link rel=preload as=image href=https://blog.ww93.fun/github.svg><script defer src=https://blog.ww93.fun/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.ww93.fun/favicon.ico><link rel=apple-touch-icon href=https://blog.ww93.fun/apple-touch-icon.png><meta name=generator content="Hugo 0.139.2"><meta itemprop=name content="Go Learn"><meta itemprop=description content='数据类型 array 初始化， b := [2]string{"Penn", "Teller"} 初始化，编译器计算自动计算长度 b := [...]string{"Penn", "Teller"} 数组的赋值是直接拷贝整个数组，变量赋值本质上是一次内存浅拷贝，切片的赋值是拷贝了切片头，字符串的赋值是拷贝了字符串的头部，接口变量的赋值同样是浅拷贝 string Strings, bytes, runes and characters in Go
等价于一个只读的字节Slice
len 方法返回的时候字节数，非字符数
rune int32 4个字节 单括号字面量
关键字 switch 不需要break语句 支持表达式 容器 Slice - 切片 Go Slices: usage and internals
初始化， letters := []string{"a", "b", "c", "d"} make初始化， s := make([]byte, 5(leg), 5(cap,可选，不填写默认与长度相同)) 与Java不同，扩容后返回新Slicce，一定要接收返回值 nil slice 支持append s[x:y] 共享底层数据，小Slice引用大Slice，可能会早成无法被垃圾回收，使用复制去处对大Slice的引用 Map 初始化 n := map[string]int{"foo": 1, "bar": 2} make初始化 m := make(map[string]int) v1 := m["k1"] v2, ok := m["k2"] ok 判断是否存在，主要用于区分零值 range -迭代器 数组 or 切片 for i, num := range nums 字典 for k, v := range kvs for k := range kvs 字符串 for offset, runeValue := range "go" Struct 参数传递 Go 语言支持值传递，也支持指针传递。值传递涉及到结构体字段的浅拷贝，指针传递会共享结构体内容，只会拷贝指针地址'><meta itemprop=datePublished content="2022-12-17T15:48:40+08:00"><meta itemprop=dateModified content="2022-12-17T15:48:40+08:00"><meta itemprop=wordCount content="229"><meta itemprop=keywords content="Golang"><meta property="og:url" content="https://blog.ww93.fun/post/go-learn/"><meta property="og:site_name" content="Wei's Note"><meta property="og:title" content="Go Learn"><meta property="og:description" content='数据类型 array 初始化， b := [2]string{"Penn", "Teller"} 初始化，编译器计算自动计算长度 b := [...]string{"Penn", "Teller"} 数组的赋值是直接拷贝整个数组，变量赋值本质上是一次内存浅拷贝，切片的赋值是拷贝了切片头，字符串的赋值是拷贝了字符串的头部，接口变量的赋值同样是浅拷贝 string Strings, bytes, runes and characters in Go
等价于一个只读的字节Slice
len 方法返回的时候字节数，非字符数
rune int32 4个字节 单括号字面量
关键字 switch 不需要break语句 支持表达式 容器 Slice - 切片 Go Slices: usage and internals
初始化， letters := []string{"a", "b", "c", "d"} make初始化， s := make([]byte, 5(leg), 5(cap,可选，不填写默认与长度相同)) 与Java不同，扩容后返回新Slicce，一定要接收返回值 nil slice 支持append s[x:y] 共享底层数据，小Slice引用大Slice，可能会早成无法被垃圾回收，使用复制去处对大Slice的引用 Map 初始化 n := map[string]int{"foo": 1, "bar": 2} make初始化 m := make(map[string]int) v1 := m["k1"] v2, ok := m["k2"] ok 判断是否存在，主要用于区分零值 range -迭代器 数组 or 切片 for i, num := range nums 字典 for k, v := range kvs for k := range kvs 字符串 for offset, runeValue := range "go" Struct 参数传递 Go 语言支持值传递，也支持指针传递。值传递涉及到结构体字段的浅拷贝，指针传递会共享结构体内容，只会拷贝指针地址'><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-17T15:48:40+08:00"><meta property="article:modified_time" content="2022-12-17T15:48:40+08:00"><meta property="article:tag" content="Golang"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Learn"><meta name=twitter:description content='数据类型 array 初始化， b := [2]string{"Penn", "Teller"} 初始化，编译器计算自动计算长度 b := [...]string{"Penn", "Teller"} 数组的赋值是直接拷贝整个数组，变量赋值本质上是一次内存浅拷贝，切片的赋值是拷贝了切片头，字符串的赋值是拷贝了字符串的头部，接口变量的赋值同样是浅拷贝 string Strings, bytes, runes and characters in Go
等价于一个只读的字节Slice
len 方法返回的时候字节数，非字符数
rune int32 4个字节 单括号字面量
关键字 switch 不需要break语句 支持表达式 容器 Slice - 切片 Go Slices: usage and internals
初始化， letters := []string{"a", "b", "c", "d"} make初始化， s := make([]byte, 5(leg), 5(cap,可选，不填写默认与长度相同)) 与Java不同，扩容后返回新Slicce，一定要接收返回值 nil slice 支持append s[x:y] 共享底层数据，小Slice引用大Slice，可能会早成无法被垃圾回收，使用复制去处对大Slice的引用 Map 初始化 n := map[string]int{"foo": 1, "bar": 2} make初始化 m := make(map[string]int) v1 := m["k1"] v2, ok := m["k2"] ok 判断是否存在，主要用于区分零值 range -迭代器 数组 or 切片 for i, num := range nums 字典 for k, v := range kvs for k := range kvs 字符串 for offset, runeValue := range "go" Struct 参数传递 Go 语言支持值传递，也支持指针传递。值传递涉及到结构体字段的浅拷贝，指针传递会共享结构体内容，只会拷贝指针地址'><link rel=canonical href=https://blog.ww93.fun/post/go-learn/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://blog.ww93.fun/>Wei's Note</a><div class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#fff".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/>Home</a>
<a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/posts/>Archives</a>
<a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/tags/>Tags</a>
<a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/categories/>Categories</a></nav><nav class="mt-12 flex justify-center space-x-10 rtl:space-x-reverse dark:invert ltr:lg:ml-14 rtl:lg:mr-14 lg:mt-0 lg:items-center"><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/ww9xlll target=_blank rel=me>github</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-14><h1 class="!my-0 pb-2.5">Go Learn</h1><div class="text-xs antialiased opacity-60"><time>Dec 17, 2022</time></div></header><section><h1 id=数据类型>数据类型</h1><h2 id=array>array</h2><ol><li>初始化， <code>b := [2]string{"Penn", "Teller"}</code></li><li>初始化，编译器计算自动计算长度 <code>b := [...]string{"Penn", "Teller"}</code></li><li>数组的赋值是直接拷贝整个数组，变量赋值本质上是一次内存浅拷贝，切片的赋值是拷贝了切片头，字符串的赋值是拷贝了字符串的头部，接口变量的赋值同样是浅拷贝</li></ol><h2 id=string>string</h2><p><strong><a href=https://go.dev/blog/strings>Strings, bytes, runes and characters in Go</a></strong></p><p>等价于一个只读的字节Slice</p><p>len 方法返回的时候字节数，非字符数</p><h3 id=rune>rune</h3><p>int32 4个字节 单括号字面量</p><h1 id=关键字>关键字</h1><h2 id=switch>switch</h2><ul><li>不需要break语句</li><li>支持表达式</li></ul><h1 id=容器>容器</h1><h2 id=slice---切片>Slice - 切片</h2><p><strong><a href=https://go.dev/blog/slices-intro>Go Slices: usage and internals</a></strong></p><ol><li>初始化， <code>letters := []string{"a", "b", "c", "d"}</code></li><li>make初始化， <code>s := make([]byte, 5(leg), 5(cap,可选，不填写默认与长度相同))</code></li></ol><ul><li>与Java不同，扩容后返回新Slicce，一定要接收返回值</li><li>nil slice 支持append</li><li>s[x:y] 共享底层数据，小Slice引用大Slice，可能会早成无法被垃圾回收，使用复制去处对大Slice的引用</li></ul><h2 id=map>Map</h2><ol><li>初始化 <code>n := map[string]int{"foo": 1, "bar": 2}</code></li><li>make初始化 <code>m := make(map[string]int)</code></li><li><code>v1 := m["k1"]</code></li><li><code>v2, ok := m["k2"]</code> ok 判断是否存在，主要用于区分零值</li></ol><h2 id=range--迭代器>range -迭代器</h2><ol><li>数组 or 切片 <code>for i, num := range nums</code></li><li>字典 <code>for k, v := range kvs</code> <code>for k := range kvs</code></li><li>字符串 <code>for offset, runeValue := range "go"</code></li></ol><h1 id=struct>Struct</h1><h3 id=参数传递>参数传递</h3><p>Go 语言支持值传递，也支持指针传递。值传递涉及到结构体字段的浅拷贝，指针传递会共享结构体内容，只会拷贝指针地址</p><h3 id=匿名内嵌结构体><strong><strong>匿名内嵌结构体</strong></strong></h3><p>会继承方法，实际上是语法糖，基于组合实现继承</p><h3 id=标签>标签</h3><p>字段元数据标注，作用类似于Java注解，可用于标记json字段名等</p><h1 id=interfaces>Interfaces</h1><p>鸭子类型，不需要显示继承，</p><p>可以实现面向对象中的多态，interface{} 等价于 Java里的Object</p><h1 id=异常处理>异常处理</h1><h3 id=error>Error</h3><p>相对繁琐，但官方推荐</p><h3 id=panic>Panic</h3><p>相对简洁，类似于Java 的 throw try catch</p><h3 id=defer><strong>defer</strong></h3><p>相当于Java的finally，用于关闭流、释放资源或锁，最先 defer 的语句最后执行</p><h1 id=goroutine---协程---轻量级线程>Goroutine - 协程 - 轻量级线程</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#e6db74>&#34;xxx&#34;</span>)
</span></span></code></pre></div><h2 id=channel---通道>Channel - 通道</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 缓冲型通道，里面只能放整数
</span></span></span><span style=display:flex><span><span style=color:#75715e>// java.util. concurrent .ArrayBlockingQueue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>bufferedChannel</span> = make(<span style=color:#a6e22e>chanint</span>, <span style=color:#ae81ff>1024</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 非缓冲型通道 必须确保有协程正尝试读取，否则写操作会阻塞直到有其它协程来从通道中读
</span></span></span><span style=display:flex><span><span style=color:#75715e>// java.util.concurrent.SynchronousQueue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>unbufferedChannel</span> = make(<span style=color:#a6e22e>chanint</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 箭头语法糖 &lt;-
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>channel</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>x</span> <span style=color:#75715e>// 写通道
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>channel</span> <span style=color:#75715e>// 读通道
</span></span></span></code></pre></div><h3 id=读写阻塞>读写阻塞</h3><p>通道满，写协程阻塞，直至有协程读取，唤醒一个写阻塞协程</p><p>通道空，读协程阻塞，直至有协程写入，唤醒一个读阻塞协程</p><h3 id=关闭通道>关闭通道</h3><p>确保通道写安全的最好方式是由负责写通道的协程自己来关闭通道，通道关闭后读协程还可以读未读区的数据</p><p>支持for range 语法，空通道循环暂停并阻塞当前协程，通道关闭阻塞停止且循环结束</p><h3 id=select-多通道>Select 多通道</h3><p>通道「多路复用」语法糖，同时管理多个通道读写，所有通道都不能读写就整体阻塞，只要有一个通道可以读写就会继续</p><p>select语句default可以决定通道读写操作是否阻塞</p><h3 id=内部结构>内部结构</h3><p>循环数组通过读写偏移量来控制元素发送和接受。一个全局锁来控制并发并保证线程安全。两个队列分别保存阻塞的发送和接收协程</p><blockquote><p>与Java 语言内置的 <a href=https://www.notion.so/ArrayBlockQueue-b1e197d463d345adbf8e68969bc48fda>ArrayBlockingQueue</a> 结构如出一辙。队列在本质上是使用共享变量加锁的方式来实现的，共享变量才是并行交流的本质</p></blockquote><blockquote><p>所以读者请不要认为 Go 语言的通道很神奇，Go 语言只是对通道设计了一套便于使用的语法糖，让这套数据结构显的平易近人。它在内部实现上和其它语言的并发队列大同小异</p></blockquote><h1 id=并发工具>并发工具</h1><h1 id=waitgroup>WaitGroup</h1><p>类似于CountDownLatch</p><h1 id=包管理>包管理</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//名称替换 支持同名包
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>import</span> <span style=color:#a6e22e>pmathy</span> <span style=color:#e6db74>&#34;github.com/pyloque/mathy&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#a6e22e>omathy</span> <span style=color:#e6db74>&#34;github.com/other/mathy&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 类似于Java中的static import
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>import</span> . <span style=color:#e6db74>&#34;github.com/pyloque/mathy&#34;</span>
</span></span></code></pre></div><h1 id=参考>参考</h1><p>1、<a href=https://www.zhihu.com/column/quickgo>快学 Go 语言</a> by <a href=https://www.zhihu.com/people/codehole>老钱</a></p><p>2、<a href=https://gobyexample.com/>Go by Example</a></p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 ltr:mr-1.5 rtl:ml-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://blog.ww93.fun/tags/golang>golang</a></footer><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://blog.ww93.fun/post/gin-learn/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Gin Learn</span></a>
<a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href=https://blog.ww93.fun/post/hello-world/><span>Hello World</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><div class=mt-24 id=disqus_thread></div><script>const disqusShortname="ww9xlll",script=document.createElement("script");script.src="https://"+disqusShortname+".disqus.com/embed.js",script.setAttribute("data-timestamp",+new Date),document.head.appendChild(script)</script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-[--w] items-center px-8 text-xs uppercase tracking-wider opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=https://blog.ww93.fun/>Wei's Note</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>